<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sidewalk Surfer 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.85);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            color: white;
            display: none;
            z-index: 200;
        }
        #gameOver h1 {
            margin: 0 0 20px 0;
            font-size: 48px;
            color: #ff6b6b;
        }
        #gameOver button {
            background: #4ecdc4;
            border: none;
            padding: 15px 40px;
            font-size: 24px;
            border-radius: 10px;
            cursor: pointer;
            color: white;
            font-weight: bold;
            margin-top: 20px;
        }
        #gameOver button:hover {
            background: #45b8b0;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div>Score: <span id="score">0</span></div>
        <div>Speed: <span id="speed">35</span> mph</div>
        <div>Lives: <span id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span></div>
    </div>
    
    <div id="gameOver">
        <h1>WIPEOUT!</h1>
        <p id="finalScore" style="font-size: 32px;"></p>
        <p style="font-size: 18px;">You crashed into something hilarious!</p>
        <button onclick="restartGame()">Try Again</button>
    </div>

    <div id="instructions">
        ‚Üê ‚Üí Arrow Keys to Move | Space to Jump
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let ball, ballVelocity = { x: 0, y: 0, z: 0 };
        let obstacles = [];
        let trackSegments = [];
        let score = 0;
        let speed = 35;
        let lives = 10;
        let isInvincible = false;
        let gameRunning = true;
        let keys = {};
        let isJumping = false;
        let gravity = -0.02;

        // Game constants
        const TRACK_WIDTH = 12;
        const LANE_COUNT = 5;
        const SEGMENT_LENGTH = 20;
        const BALL_RADIUS = 0.5;
        const JUMP_POWER = 0.35;

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 50, 150);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 10);
            camera.lookAt(0, 2, -10);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(50, 50, 50);
            sunLight.castShadow = true;
            sunLight.shadow.camera.left = -50;
            sunLight.shadow.camera.right = 50;
            sunLight.shadow.camera.top = 50;
            sunLight.shadow.camera.bottom = -50;
            scene.add(sunLight);

            // Create ball (player)
            const ballGeometry = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);
            const ballMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff1744,
                metalness: 0.3,
                roughness: 0.4
            });
            ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.position.set(0, BALL_RADIUS + 1, 0);
            ball.castShadow = true;
            scene.add(ball);

            // Create ocean on both sides
            createOcean(-TRACK_WIDTH, 'left');
            createOcean(TRACK_WIDTH, 'right');

            // Generate initial track
            for (let i = 0; i < 15; i++) {
                createTrackSegment(i * SEGMENT_LENGTH);
            }

            // Event listeners
            window.addEventListener('keydown', (e) => keys[e.key] = true);
            window.addEventListener('keyup', (e) => keys[e.key] = false);
            window.addEventListener('resize', onWindowResize);

            animate();
        }

        function createOcean(xOffset, side) {
            const oceanGeometry = new THREE.PlaneGeometry(100, 500);
            const oceanMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x006994,
                metalness: 0.8,
                roughness: 0.2
            });
            const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
            ocean.rotation.x = -Math.PI / 2;
            ocean.position.x = xOffset * 2;
            ocean.position.y = -2;
            scene.add(ocean);
        }

        function createTrackSegment(zPosition) {
            const segmentGroup = new THREE.Group();
            
            // Random chance for gap (20%)
            const hasGap = Math.random() < 0.2;
            
            if (!hasGap) {
                // Normal track
                const trackGeometry = new THREE.BoxGeometry(TRACK_WIDTH, 0.5, SEGMENT_LENGTH);
                const trackMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xcccccc,
                    roughness: 0.8
                });
                const track = new THREE.Mesh(trackGeometry, trackMaterial);
                track.receiveShadow = true;
                segmentGroup.add(track);

                // Add stripes
                for (let i = 0; i < 3; i++) {
                    const stripeGeometry = new THREE.BoxGeometry(0.3, 0.51, SEGMENT_LENGTH);
                    const stripeMaterial = new THREE.MeshStandardMaterial({ color: 0xffeb3b });
                    const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                    stripe.position.x = (i - 1) * 4;
                    segmentGroup.add(stripe);
                }

                // Randomly add obstacles (40% chance)
                if (Math.random() < 0.4 && zPosition < -20) {
                    createObstacle(segmentGroup);
                }
            } else {
                // Gap with ramps on both sides
                const rampLength = 4;
                
                // Entry ramp
                const entryRamp = createRamp();
                entryRamp.position.z = SEGMENT_LENGTH / 2 - rampLength / 2;
                segmentGroup.add(entryRamp);

                // Exit ramp
                const exitRamp = createRamp();
                exitRamp.rotation.z = Math.PI;
                exitRamp.position.z = -SEGMENT_LENGTH / 2 + rampLength / 2;
                segmentGroup.add(exitRamp);

                segmentGroup.userData.isGap = true;
            }

            segmentGroup.position.z = -zPosition;
            scene.add(segmentGroup);
            trackSegments.push(segmentGroup);
        }

        function createRamp() {
            const rampGroup = new THREE.Group();
            const rampGeometry = new THREE.BoxGeometry(TRACK_WIDTH, 0.5, 4);
            const rampMaterial = new THREE.MeshStandardMaterial({ color: 0xff9800 });
            const ramp = new THREE.Mesh(rampGeometry, rampMaterial);
            ramp.rotation.x = -Math.PI / 8;
            ramp.position.y = 0.5;
            ramp.castShadow = true;
            ramp.receiveShadow = true;
            rampGroup.add(ramp);
            return rampGroup;
        }

        function createObstacle(parent) {
            const obstacleTypes = [
                { type: 'beachBall', color: 0xff6b6b, size: 1.5 },
                { type: 'umbrella', color: 0xff1744, size: 2 },
                { type: 'flamingo', color: 0xff69b4, size: 1.8 },
                { type: 'cone', color: 0xff5722, size: 1.2 },
                { type: 'cooler', color: 0x2196f3, size: 1.5 },
                { type: 'rubberDucky', color: 0xffeb3b, size: 2 },
                { type: 'shoppingCart', color: 0x757575, size: 1.5 },
                { type: 'pizza', color: 0xff6f00, size: 1.2 },
                { type: 'watermelon', color: 0x4caf50, size: 1.4 },
                { type: 'dog', color: 0x8d6e63, size: 1.3 },
                { type: 'surfboard', color: 0x00bcd4, size: 1.8 },
                { type: 'banana', color: 0xffeb3b, size: 0.8 },
                { type: 'sandcastle', color: 0xfdd835, size: 1.6 },
                { type: 'beachChair', color: 0xf44336, size: 1.5 },
                { type: 'sunglasses', color: 0x212121, size: 1.8 },
                { type: 'inflatable', color: 0x9c27b0, size: 2.2 },
                { type: 'seagull', color: 0xeeeeee, size: 1.0 },
                { type: 'skateboard', color: 0x795548, size: 1.0 }
            ];

            const obstacleData = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
            let obstacle;

            switch(obstacleData.type) {
                case 'beachBall':
                    const ballGeo = new THREE.SphereGeometry(obstacleData.size, 16, 16);
                    const ballMat = new THREE.MeshStandardMaterial({ color: obstacleData.color });
                    obstacle = new THREE.Mesh(ballGeo, ballMat);
                    obstacle.position.y = obstacleData.size;
                    break;
                case 'umbrella':
                    const umbrellaGroup = new THREE.Group();
                    const poleGeo = new THREE.CylinderGeometry(0.1, 0.1, 3);
                    const poleMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                    const pole = new THREE.Mesh(poleGeo, poleMat);
                    pole.position.y = 1.5;
                    umbrellaGroup.add(pole);
                    
                    const topGeo = new THREE.ConeGeometry(1.5, 1, 8);
                    const topMat = new THREE.MeshStandardMaterial({ color: obstacleData.color });
                    const top = new THREE.Mesh(topGeo, topMat);
                    top.position.y = 3.5;
                    umbrellaGroup.add(top);
                    obstacle = umbrellaGroup;
                    break;
                case 'flamingo':
                    const flamingoGeo = new THREE.SphereGeometry(obstacleData.size, 16, 16);
                    const flamingoMat = new THREE.MeshStandardMaterial({ color: obstacleData.color });
                    obstacle = new THREE.Mesh(flamingoGeo, flamingoMat);
                    obstacle.position.y = obstacleData.size;
                    obstacle.scale.y = 1.5;
                    break;
                case 'cone':
                    const coneGeo = new THREE.ConeGeometry(obstacleData.size, obstacleData.size * 2, 8);
                    const coneMat = new THREE.MeshStandardMaterial({ color: obstacleData.color });
                    obstacle = new THREE.Mesh(coneGeo, coneMat);
                    obstacle.position.y = obstacleData.size;
                    break;
                case 'cooler':
                    const coolerGeo = new THREE.BoxGeometry(obstacleData.size, obstacleData.size, obstacleData.size * 1.5);
                    const coolerMat = new THREE.MeshStandardMaterial({ color: obstacleData.color });
                    obstacle = new THREE.Mesh(coolerGeo, coolerMat);
                    obstacle.position.y = obstacleData.size / 2;
                    break;
                case 'rubberDucky':
                    const duckyGroup = new THREE.Group();
                    const bodyGeo = new THREE.SphereGeometry(obstacleData.size, 16, 16);
                    const bodyMat = new THREE.MeshStandardMaterial({ color: obstacleData.color });
                    const body = new THREE.Mesh(bodyGeo, bodyMat);
                    body.scale.set(1, 0.8, 1);
                    duckyGroup.add(body);
                    const headGeo = new THREE.SphereGeometry(obstacleData.size * 0.6, 16, 16);
                    const head = new THREE.Mesh(headGeo, bodyMat);
                    head.position.set(0, obstacleData.size * 0.8, obstacleData.size * 0.3);
                    duckyGroup.add(head);
                    obstacle = duckyGroup;
                    obstacle.position.y = obstacleData.size;
                    break;
                case 'shoppingCart':
                    const cartGroup = new THREE.Group();
                    const basketGeo = new THREE.BoxGeometry(1.5, 1.2, 1);
                    const basketMat = new THREE.MeshStandardMaterial({ color: obstacleData.color });
                    const basket = new THREE.Mesh(basketGeo, basketMat);
                    basket.position.y = 0.8;
                    cartGroup.add(basket);
                    for (let i = 0; i < 4; i++) {
                        const wheelGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.1);
                        const wheel = new THREE.Mesh(wheelGeo, new THREE.MeshStandardMaterial({ color: 0x333333 }));
                        wheel.rotation.z = Math.PI / 2;
                        wheel.position.set(i % 2 ? 0.6 : -0.6, 0.15, i < 2 ? 0.4 : -0.4);
                        cartGroup.add(wheel);
                    }
                    obstacle = cartGroup;
                    break;
                case 'pizza':
                    const pizzaGeo = new THREE.CylinderGeometry(obstacleData.size, obstacleData.size, 0.2, 8);
                    const pizzaMat = new THREE.MeshStandardMaterial({ color: obstacleData.color });
                    obstacle = new THREE.Mesh(pizzaGeo, pizzaMat);
                    obstacle.position.y = 0.5;
                    obstacle.rotation.x = Math.PI / 2;
                    break;
                case 'watermelon':
                    const melonGeo = new THREE.SphereGeometry(obstacleData.size, 16, 16);
                    const melonMat = new THREE.MeshStandardMaterial({ color: obstacleData.color });
                    obstacle = new THREE.Mesh(melonGeo, melonMat);
                    obstacle.position.y = obstacleData.size;
                    obstacle.scale.y = 1.2;
                    break;
                case 'dog':
                    const dogGroup = new THREE.Group();
                    const dogBodyGeo = new THREE.BoxGeometry(1, 0.8, 1.5);
                    const dogMat = new THREE.MeshStandardMaterial({ color: obstacleData.color });
                    const dogBody = new THREE.Mesh(dogBodyGeo, dogMat);
                    dogBody.position.y = 0.6;
                    dogGroup.add(dogBody);
                    const dogHeadGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
                    const dogHead = new THREE.Mesh(dogHeadGeo, dogMat);
                    dogHead.position.set(0, 0.8, 0.9);
                    dogGroup.add(dogHead);
                    obstacle = dogGroup;
                    break;
                case 'surfboard':
                    const boardGeo = new THREE.BoxGeometry(0.6, 0.2, 3);
                    const boardMat = new THREE.MeshStandardMaterial({ color: obstacleData.color });
                    obstacle = new THREE.Mesh(boardGeo, boardMat);
                    obstacle.position.y = 1;
                    obstacle.rotation.z = Math.PI / 6;
                    break;
                case 'banana':
                    const bananaGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 8);
                    const bananaMat = new THREE.MeshStandardMaterial({ color: obstacleData.color });
                    obstacle = new THREE.Mesh(bananaGeo, bananaMat);
                    obstacle.position.y = 0.3;
                    obstacle.rotation.x = Math.PI / 2;
                    obstacle.rotation.z = Math.PI / 4;
                    break;
                case 'sandcastle':
                    const castleGroup = new THREE.Group();
                    const tower1 = new THREE.CylinderGeometry(0.4, 0.5, 1.5, 8);
                    const castleMat = new THREE.MeshStandardMaterial({ color: obstacleData.color });
                    const t1 = new THREE.Mesh(tower1, castleMat);
                    t1.position.y = 0.75;
                    castleGroup.add(t1);
                    const cone1 = new THREE.ConeGeometry(0.4, 0.5, 8);
                    const c1 = new THREE.Mesh(cone1, castleMat);
                    c1.position.y = 1.75;
                    castleGroup.add(c1);
                    obstacle = castleGroup;
                    break;
                case 'beachChair':
                    const chairGroup = new THREE.Group();
                    const seatGeo = new THREE.BoxGeometry(1.2, 0.2, 1);
                    const chairMat = new THREE.MeshStandardMaterial({ color: obstacleData.color });
                    const seat = new THREE.Mesh(seatGeo, chairMat);
                    seat.position.y = 0.5;
                    chairGroup.add(seat);
                    const backGeo = new THREE.BoxGeometry(1.2, 1.5, 0.2);
                    const back = new THREE.Mesh(backGeo, chairMat);
                    back.position.set(0, 1.2, -0.4);
                    chairGroup.add(back);
                    obstacle = chairGroup;
                    break;
                case 'sunglasses':
                    const glassesGroup = new THREE.Group();
                    const lensGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.1, 16);
                    const glassMat = new THREE.MeshStandardMaterial({ color: obstacleData.color, metalness: 0.8 });
                    const lens1 = new THREE.Mesh(lensGeo, glassMat);
                    lens1.rotation.x = Math.PI / 2;
                    lens1.position.x = -0.7;
                    glassesGroup.add(lens1);
                    const lens2 = lens1.clone();
                    lens2.position.x = 0.7;
                    glassesGroup.add(lens2);
                    obstacle = glassesGroup;
                    obstacle.position.y = 1.5;
                    obstacle.scale.set(1.5, 1.5, 1.5);
                    break;
                case 'inflatable':
                    const inflatableGeo = new THREE.TorusGeometry(1.2, 0.5, 16, 32);
                    const inflatableMat = new THREE.MeshStandardMaterial({ color: obstacleData.color });
                    obstacle = new THREE.Mesh(inflatableGeo, inflatableMat);
                    obstacle.position.y = 1;
                    obstacle.rotation.x = Math.PI / 2;
                    break;
                case 'seagull':
                    const seagullGroup = new THREE.Group();
                    const birdBodyGeo = new THREE.SphereGeometry(0.4, 16, 16);
                    const birdMat = new THREE.MeshStandardMaterial({ color: obstacleData.color });
                    const birdBody = new THREE.Mesh(birdBodyGeo, birdMat);
                    seagullGroup.add(birdBody);
                    const wingGeo = new THREE.BoxGeometry(1.5, 0.1, 0.4);
                    const wings = new THREE.Mesh(wingGeo, birdMat);
                    wings.position.y = 0;
                    seagullGroup.add(wings);
                    obstacle = seagullGroup;
                    obstacle.position.y = 2.5 + Math.sin(Date.now() * 0.001) * 0.3;
                    break;
                case 'skateboard':
                    const skateGroup = new THREE.Group();
                    const deckGeo = new THREE.BoxGeometry(0.4, 0.1, 1.2);
                    const skateMat = new THREE.MeshStandardMaterial({ color: obstacleData.color });
                    const deck = new THREE.Mesh(deckGeo, skateMat);
                    skateGroup.add(deck);
                    for (let i = 0; i < 4; i++) {
                        const wheelGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.05);
                        const wheel = new THREE.Mesh(wheelGeo, new THREE.MeshStandardMaterial({ color: 0x333333 }));
                        wheel.rotation.z = Math.PI / 2;
                        wheel.position.set(i % 2 ? 0.15 : -0.15, -0.15, i < 2 ? 0.4 : -0.4);
                        skateGroup.add(wheel);
                    }
                    obstacle = skateGroup;
                    obstacle.position.y = 0.3;
                    break;
            }

            const laneIndex = Math.floor(Math.random() * LANE_COUNT);
            const laneWidth = TRACK_WIDTH / LANE_COUNT;
            obstacle.position.x = (laneIndex - 2) * laneWidth;
            obstacle.position.z = Math.random() * 10 - 5;
            obstacle.castShadow = true;
            
            obstacle.userData.isObstacle = true;
            obstacle.userData.size = obstacleData.size;
            
            parent.add(obstacle);
            obstacles.push({ mesh: obstacle, parent: parent });
        }

        function handleInput() {
            if (!gameRunning) return;

            const moveSpeed = 0.3;
            const maxX = TRACK_WIDTH / 2 - BALL_RADIUS;

            if (keys['ArrowLeft'] || keys['a']) {
                ball.position.x -= moveSpeed;
            }
            if (keys['ArrowRight'] || keys['d']) {
                ball.position.x += moveSpeed;
            }

            ball.position.x = Math.max(-maxX, Math.min(maxX, ball.position.x));

            if ((keys[' '] || keys['ArrowUp']) && !isJumping && ball.position.y <= BALL_RADIUS + 1.1) {
                ballVelocity.y = JUMP_POWER;
                isJumping = true;
            }
        }

        function updatePhysics() {
            if (!gameRunning) return;

            // Apply gravity
            ballVelocity.y += gravity;
            ball.position.y += ballVelocity.y;

            // Ground collision
            const groundY = BALL_RADIUS + 1;
            if (ball.position.y <= groundY) {
                ball.position.y = groundY;
                ballVelocity.y = 0;
                isJumping = false;
            }

            // Check if fallen off track
            if (ball.position.y < -10 && !isInvincible) {
                loseLife();
                ball.position.y = BALL_RADIUS + 1;
                ballVelocity.y = 0;
            }

            // Rotate ball
            ball.rotation.x += 0.1 * (speed / 35);
        }

        function updateTrack() {
            if (!gameRunning) return;

            const moveSpeed = speed / 35;

            trackSegments.forEach((segment, index) => {
                segment.position.z += moveSpeed;

                if (segment.position.z > 20) {
                    scene.remove(segment);
                    trackSegments.splice(index, 1);
                    createTrackSegment(trackSegments[trackSegments.length - 1].position.z * -1 + SEGMENT_LENGTH);
                }
            });

            // Check gap collision
            trackSegments.forEach(segment => {
                if (segment.userData.isGap && !isInvincible) {
                    const distZ = Math.abs(ball.position.z - segment.position.z);
                    if (distZ < 5 && ball.position.y < 2) {
                        // Fell in gap
                        loseLife();
                    }
                }
            });
        }

        function checkCollisions() {
            if (!gameRunning || isInvincible) return;

            obstacles.forEach((obs, index) => {
                const worldPos = new THREE.Vector3();
                obs.mesh.getWorldPosition(worldPos);

                const distance = ball.position.distanceTo(worldPos);
                const collisionDist = BALL_RADIUS + (obs.mesh.userData.size || 1);

                if (distance < collisionDist) {
                    loseLife();
                }

                // Remove obstacles that passed
                if (worldPos.z > 15) {
                    if (obs.parent) {
                        obs.parent.remove(obs.mesh);
                    }
                    obstacles.splice(index, 1);
                }
            });
        }

        function loseLife() {
            lives--;
            updateLivesDisplay();
            
            if (lives <= 0) {
                gameOver();
                return;
            }

            // Brief invincibility and visual feedback
            isInvincible = true;
            const originalColor = ball.material.color.getHex();
            ball.material.color.setHex(0xffffff);
            
            setTimeout(() => {
                ball.material.color.setHex(originalColor);
                isInvincible = false;
            }, 1000);

            // Bounce back slightly
            ballVelocity.y = 0.2;
        }

        function updateLivesDisplay() {
            const heartsDisplay = '‚ù§Ô∏è'.repeat(lives) + 'üíî'.repeat(10 - lives);
            document.getElementById('lives').textContent = heartsDisplay;
        }

        function updateScore() {
            if (!gameRunning) return;

            score += Math.floor(speed / 10);
            speed += 0.008;
            
            document.getElementById('score').textContent = Math.floor(score);
            document.getElementById('speed').textContent = Math.floor(speed);
        }

        function gameOver() {
            gameRunning = false;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = `Final Score: ${Math.floor(score)}`;
        }

        function restartGame() {
            // Clean up
            obstacles.forEach(obs => {
                if (obs.parent) {
                    obs.parent.remove(obs.mesh);
                }
            });
            obstacles = [];
            
            trackSegments.forEach(segment => scene.remove(segment));
            trackSegments = [];

            // Reset state
            score = 0;
            speed = 35;
            lives = 10;
            isInvincible = false;
            gameRunning = true;
            isJumping = false;
            ballVelocity = { x: 0, y: 0, z: 0 };
            ball.position.set(0, BALL_RADIUS + 1, 0);
            ball.rotation.set(0, 0, 0);
            ball.material.color.setHex(0xff1744);

            // Recreate track
            for (let i = 0; i < 15; i++) {
                createTrackSegment(i * SEGMENT_LENGTH);
            }

            updateLivesDisplay();
            document.getElementById('gameOver').style.display = 'none';
        }

        function animate() {
            requestAnimationFrame(animate);

            handleInput();
            updatePhysics();
            updateTrack();
            checkCollisions();
            updateScore();

            // Camera follows ball
            camera.position.x = ball.position.x * 0.3;
            camera.position.z = ball.position.z + 10;

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>