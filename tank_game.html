<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöó Tank Battle Arena üéØ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            user-select: none;
        }
        canvas {
            display: block;
            background: radial-gradient(circle at center, #2a2a3e 0%, #16213e 50%, #0f1419 100%);
            cursor: crosshair;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            font-size: 18px;
            text-shadow: 0 0 10px #00ff88;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ff88;
        }
        #ui div {
            margin: 5px 0;
        }
        .health-bar {
            width: 200px;
            height: 20px;
            background: #333;
            border: 2px solid #00ff88;
            border-radius: 10px;
            overflow: hidden;
            margin: 5px 0;
        }
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff3333, #ffaa33, #33ff33);
            transition: width 0.3s ease;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 14px;
            opacity: 0.8;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        #gameOver, #levelComplete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 200;
            border: 3px solid #00ff88;
        }
        #gameOver h2, #levelComplete h2 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #ff3333;
        }
        #levelComplete h2 {
            color: #33ff33;
        }
        button {
            background: linear-gradient(135deg, #00ff88, #00aa55);
            color: #000;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s ease;
        }
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px #00ff88;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="ui">
        <div>üéØ Score: <span id="score">0</span></div>
        <div>üåä Wave: <span id="wave">1</span></div>
        <div>üëæ Enemies: <span id="enemies">0</span></div>
        <div>‚ù§Ô∏è Health:</div>
        <div class="health-bar">
            <div class="health-fill" id="healthBar" style="width: 100%"></div>
        </div>
        <div>üî• Firepower: <span id="firepower">Normal</span></div>
    </div>
    
    <div id="instructions">
        WASD: Move Tank | Mouse: Aim | Click: Fire | Space: Special Weapon
    </div>
    
    <div id="gameOver">
        <h2>üí• GAME OVER üí•</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <p>Waves Survived: <span id="finalWave">0</span></p>
        <button onclick="game.restart()">Try Again</button>
    </div>
    
    <div id="levelComplete">
        <h2>üéâ WAVE COMPLETE! üéâ</h2>
        <p>Score: <span id="waveScore">0</span></p>
        <button onclick="game.nextWave()">Next Wave</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Resize canvas
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // Audio Context for sound effects
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(type) {
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                switch(type) {
                    case 'shoot':
                        oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.1);
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.1);
                        break;
                    case 'explosion':
                        oscillator.type = 'sawtooth';
                        oscillator.frequency.setValueAtTime(80, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(30, audioContext.currentTime + 0.2);
                        gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.2);
                        break;
                    case 'hit':
                        oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.05);
                        break;
                    case 'powerup':
                        oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.1);
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.1);
                        break;
                }
            } catch(e) {
                // Silently fail if audio is not supported
            }
        }

        // Game classes
        class Tank {
            constructor(x, y, color = '#4a7c59', isPlayer = false) {
                this.x = x;
                this.y = y;
                this.angle = 0;
                this.speed = 0;
                this.maxSpeed = isPlayer ? 4 : 2;
                this.turnSpeed = 0.08;
                this.size = 25;
                this.color = color;
                this.health = 100;
                this.maxHealth = 100;
                this.isPlayer = isPlayer;
                this.lastShot = 0;
                this.fireRate = isPlayer ? 300 : 2000;
                this.turretAngle = 0;
            }

            update() {
                if (this.isPlayer) {
                    // Player movement handled by input
                    this.x += Math.cos(this.angle) * this.speed;
                    this.y += Math.sin(this.angle) * this.speed;

                    // Bounce off walls
                    if (this.x < this.size) { this.x = this.size; this.speed *= -0.5; }
                    if (this.x > canvas.width - this.size) { this.x = canvas.width - this.size; this.speed *= -0.5; }
                    if (this.y < this.size) { this.y = this.size; this.speed *= -0.5; }
                    if (this.y > canvas.height - this.size) { this.y = canvas.height - this.size; this.speed *= -0.5; }
                } else {
                    // AI behavior
                    this.aiUpdate();
                }
            }

            aiUpdate() {
                // Simple AI: move towards player and shoot
                const dx = game.player.x - this.x;
                const dy = game.player.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Aim at player
                this.turretAngle = Math.atan2(dy, dx);
                
                // Move towards player if far, maintain distance if close
                if (distance > 200) {
                    this.angle = Math.atan2(dy, dx);
                    this.speed = Math.min(this.speed + 0.1, this.maxSpeed);
                } else if (distance < 150) {
                    this.angle = Math.atan2(dy, dx) + Math.PI;
                    this.speed = Math.max(this.speed - 0.1, -this.maxSpeed/2);
                } else {
                    this.speed *= 0.9;
                }

                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;

                // Shoot at player
                const now = Date.now();
                if (now - this.lastShot > this.fireRate && distance < 300) {
                    this.shoot();
                    this.lastShot = now;
                }
            }

            shoot() {
                const bullet = new Bullet(
                    this.x + Math.cos(this.turretAngle) * this.size,
                    this.y + Math.sin(this.turretAngle) * this.size,
                    this.turretAngle,
                    this.isPlayer
                );
                game.bullets.push(bullet);
                playSound('shoot');
            }

            takeDamage(damage) {
                this.health -= damage;
                playSound('hit');
                
                // Create hit particles
                for (let i = 0; i < 5; i++) {
                    game.particles.push(new Particle(
                        this.x + (Math.random() - 0.5) * this.size,
                        this.y + (Math.random() - 0.5) * this.size,
                        '#ff6600'
                    ));
                }
                
                if (this.health <= 0) {
                    this.destroy();
                    return true;
                }
                return false;
            }

            destroy() {
                // Create explosion
                for (let i = 0; i < 20; i++) {
                    game.particles.push(new Particle(this.x, this.y, this.color));
                }
                playSound('explosion');
            }

            draw(ctx) {
                // Draw tank body
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Main body
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.isPlayer ? '#00ff88' : '#ff3333';
                ctx.shadowBlur = 10;
                ctx.fillRect(-this.size, -this.size/2, this.size * 2, this.size);
                
                // Tracks
                ctx.fillStyle = '#333';
                ctx.shadowBlur = 0;
                ctx.fillRect(-this.size, -this.size/2 - 5, this.size * 2, 5);
                ctx.fillRect(-this.size, this.size/2, this.size * 2, 5);

                ctx.restore();

                // Draw turret
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.turretAngle);

                // Turret base
                ctx.fillStyle = this.isPlayer ? '#228B22' : '#8B2222';
                ctx.shadowColor = this.isPlayer ? '#00ff88' : '#ff3333';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(0, 0, 12, 0, Math.PI * 2);
                ctx.fill();

                // Barrel
                ctx.fillStyle = '#111';
                ctx.shadowBlur = 0;
                ctx.fillRect(10, -3, 20, 6);

                ctx.restore();

                // Health bar for enemies
                if (!this.isPlayer && this.health < this.maxHealth) {
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(this.x - 20, this.y - this.size - 15, 40, 4);
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(this.x - 20, this.y - this.size - 15, 40 * (this.health / this.maxHealth), 4);
                }
            }
        }

        class Bullet {
            constructor(x, y, angle, isPlayerBullet = true) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.speed = 8;
                this.damage = 25;
                this.isPlayerBullet = isPlayerBullet;
                this.life = 100;
            }

            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                this.life--;

                // Check boundaries
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height || this.life <= 0) {
                    return false;
                }
                return true;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                ctx.fillStyle = this.isPlayerBullet ? '#ffaa00' : '#ff3333';
                ctx.shadowColor = this.isPlayerBullet ? '#ffff00' : '#ff0000';
                ctx.shadowBlur = 5;
                ctx.fillRect(-3, -1, 8, 2);
                
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.life = 30;
                this.maxLife = 30;
                this.color = color;
                this.size = 2 + Math.random() * 3;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.95;
                this.vy *= 0.95;
                this.life--;
                return this.life > 0;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life / this.maxLife;
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type; // 'health', 'rapidfire', 'damage'
                this.size = 15;
                this.bobOffset = Math.random() * Math.PI * 2;
            }

            update() {
                // Bob up and down
                this.bobOffset += 0.05;
                return true;
            }

            draw(ctx) {
                const bobY = Math.sin(this.bobOffset) * 5;
                
                ctx.save();
                ctx.translate(this.x, this.y + bobY);
                
                // Glow effect
                ctx.shadowColor = '#00ff88';
                ctx.shadowBlur = 15;
                
                switch(this.type) {
                    case 'health':
                        ctx.fillStyle = '#ff3333';
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('‚ù§Ô∏è', 0, 0);
                        break;
                    case 'rapidfire':
                        ctx.fillStyle = '#ffaa00';
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('‚ö°', 0, 0);
                        break;
                    case 'damage':
                        ctx.fillStyle = '#ff00ff';
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('üí•', 0, 0);
                        break;
                }
                
                ctx.restore();
            }
        }

        // Game class
        class Game {
            constructor() {
                this.player = new Tank(canvas.width / 2, canvas.height / 2, '#4a7c59', true);
                this.enemies = [];
                this.bullets = [];
                this.particles = [];
                this.powerUps = [];
                this.score = 0;
                this.wave = 1;
                this.gameOver = false;
                this.waveComplete = false;
                this.keys = {};
                this.mouseX = 0;
                this.mouseY = 0;
                
                this.setupEventListeners();
                this.spawnWave(this.wave);
                this.gameLoop();
            }

            setupEventListeners() {
                window.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.specialWeapon();
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    this.mouseX = e.clientX;
                    this.mouseY = e.clientY;
                });
                
                canvas.addEventListener('click', (e) => {
                    if (!this.gameOver && !this.waveComplete) {
                        this.playerShoot();
                    }
                });
            }

            playerShoot() {
                const now = Date.now();
                if (now - this.player.lastShot > this.player.fireRate) {
                    this.player.shoot();
                    this.player.lastShot = now;
                }
            }

            specialWeapon() {
                // Create explosion around player
                for (let i = 0; i < 30; i++) {
                    const angle = (Math.PI * 2 * i) / 30;
                    const bullet = new Bullet(
                        this.player.x + Math.cos(angle) * 30,
                        this.player.y + Math.sin(angle) * 30,
                        angle,
                        true
                    );
                    bullet.damage = 50;
                    this.bullets.push(bullet);
                }
                playSound('explosion');
            }

            spawnWave(waveNumber) {
                const enemyCount = 3 + waveNumber * 2;
                console.log(`Spawning wave ${waveNumber} with ${enemyCount} enemies`);
                
                for (let i = 0; i < enemyCount; i++) {
                    const angle = (Math.PI * 2 * i) / enemyCount;
                    const distance = 200 + Math.random() * 200;
                    const x = canvas.width / 2 + Math.cos(angle) * distance;
                    const y = canvas.height / 2 + Math.sin(angle) * distance;
                    
                    // Ensure enemies spawn within bounds
                    const enemyX = Math.max(50, Math.min(canvas.width - 50, x));
                    const enemyY = Math.max(50, Math.min(canvas.height - 50, y));
                    
                    const enemy = new Tank(enemyX, enemyY, '#8B2222', false);
                    this.enemies.push(enemy);
                    console.log(`Spawned enemy at (${enemyX}, ${enemyY})`);
                }
            }

            update() {
                if (this.gameOver || this.waveComplete) return;

                // Update player
                if (this.keys['KeyW'] || this.keys['ArrowUp']) {
                    this.player.speed = Math.min(this.player.speed + 0.2, this.player.maxSpeed);
                } else if (this.keys['KeyS'] || this.keys['ArrowDown']) {
                    this.player.speed = Math.max(this.player.speed - 0.3, -this.player.maxSpeed / 2);
                } else {
                    this.player.speed *= 0.92;
                }

                if (this.keys['KeyA'] || this.keys['ArrowLeft']) {
                    this.player.angle -= this.player.turnSpeed;
                }
                if (this.keys['KeyD'] || this.keys['ArrowRight']) {
                    this.player.angle += this.player.turnSpeed;
                }

                // Update player turret to aim at mouse
                const dx = this.mouseX - this.player.x;
                const dy = this.mouseY - this.player.y;
                this.player.turretAngle = Math.atan2(dy, dx);

                this.player.update();

                // Update enemies
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    this.enemies[i].update();
                }

                // Update bullets
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    if (!this.bullets[i].update()) {
                        this.bullets.splice(i, 1);
                        continue;
                    }

                    // Check collisions
                    const bullet = this.bullets[i];
                    
                    if (bullet.isPlayerBullet) {
                        // Check enemy hits
                        for (let j = this.enemies.length - 1; j >= 0; j--) {
                            const enemy = this.enemies[j];
                            const dx = bullet.x - enemy.x;
                            const dy = bullet.y - enemy.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < enemy.size) {
                                if (enemy.takeDamage(bullet.damage)) {
                                    this.enemies.splice(j, 1);
                                    this.score += 100;
                                    
                                    // Chance to spawn power-up
                                    if (Math.random() < 0.2) {
                                        const types = ['health', 'rapidfire', 'damage'];
                                        const type = types[Math.floor(Math.random() * types.length)];
                                        this.powerUps.push(new PowerUp(enemy.x, enemy.y, type));
                                    }
                                }
                                this.bullets.splice(i, 1);
                                break;
                            }
                        }
                    } else {
                        // Check player hit
                        const dx = bullet.x - this.player.x;
                        const dy = bullet.y - this.player.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < this.player.size) {
                            if (this.player.takeDamage(bullet.damage)) {
                                this.endGame();
                            }
                            this.bullets.splice(i, 1);
                            this.updateHealthBar();
                        }
                    }
                }

                // Update particles
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    if (!this.particles[i].update()) {
                        this.particles.splice(i, 1);
                    }
                }

                // Update power-ups
                for (let i = this.powerUps.length - 1; i >= 0; i--) {
                    this.powerUps[i].update();
                    
                    // Check player collection
                    const powerUp = this.powerUps[i];
                    const dx = powerUp.x - this.player.x;
                    const dy = powerUp.y - this.player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < this.player.size + powerUp.size) {
                        this.collectPowerUp(powerUp);
                        this.powerUps.splice(i, 1);
                    }
                }

                // Check wave completion
                if (this.enemies.length === 0) {
                    this.waveComplete = true;
                    this.showWaveComplete();
                }

                this.updateUI();
            }

            collectPowerUp(powerUp) {
                playSound('powerup');
                
                switch(powerUp.type) {
                    case 'health':
                        this.player.health = Math.min(this.player.health + 30, this.player.maxHealth);
                        this.updateHealthBar();
                        break;
                    case 'rapidfire':
                        this.player.fireRate = 100;
                        setTimeout(() => this.player.fireRate = 300, 5000);
                        document.getElementById('firepower').textContent = 'Rapid Fire!';
                        setTimeout(() => document.getElementById('firepower').textContent = 'Normal', 5000);
                        break;
                    case 'damage':
                        // Temporary damage boost handled in bullet creation
                        document.getElementById('firepower').textContent = 'Double Damage!';
                        setTimeout(() => document.getElementById('firepower').textContent = 'Normal', 5000);
                        break;
                }
                
                this.score += 50;
            }

            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('wave').textContent = this.wave;
                document.getElementById('enemies').textContent = this.enemies.length;
            }

            updateHealthBar() {
                const healthPercent = Math.max(0, this.player.health / this.player.maxHealth * 100);
                document.getElementById('healthBar').style.width = healthPercent + '%';
            }

            draw() {
                // Clear canvas
                ctx.fillStyle = 'rgba(15, 20, 25, 0.9)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw game objects in order
                this.powerUps.forEach(powerUp => powerUp.draw(ctx));
                this.particles.forEach(particle => particle.draw(ctx));
                this.bullets.forEach(bullet => bullet.draw(ctx));
                this.enemies.forEach(enemy => enemy.draw(ctx));
                this.player.draw(ctx);

                // Debug info
                ctx.fillStyle = '#ffffff';
                ctx.font = '14px Arial';
                ctx.fillText(`Player: (${Math.round(this.player.x)}, ${Math.round(this.player.y)})`, 10, canvas.height - 60);
                ctx.fillText(`Enemies: ${this.enemies.length}`, 10, canvas.height - 40);
                ctx.fillText(`Bullets: ${this.bullets.length}`, 10, canvas.height - 20);
            }

            gameLoop() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }

            showWaveComplete() {
                document.getElementById('waveScore').textContent = this.score;
                document.getElementById('levelComplete').style.display = 'block';
            }

            nextWave() {
                this.wave++;
                this.waveComplete = false;
                document.getElementById('levelComplete').style.display = 'none';
                this.spawnWave(this.wave);
            }

            endGame() {
                this.gameOver = true;
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('finalWave').textContent = this.wave;
                document.getElementById('gameOver').style.display = 'block';
            }

            restart() {
                this.player = new Tank(canvas.width / 2, canvas.height / 2, '#4a7c59', true);
                this.enemies = [];
                this.bullets = [];
                this.particles = [];
                this.powerUps = [];
                this.score = 0;
                this.wave = 1;
                this.gameOver = false;
                this.waveComplete = false;
                
                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('levelComplete').style.display = 'none';
                this.updateHealthBar();
                this.spawnWave(this.wave);
            }
        }

        // Start game
        let game;
        window.addEventListener('load', () => {
            game = new Game();
        });
    </script>
</body>
</html>